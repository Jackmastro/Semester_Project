import cvxpy as cp
import numpy as np

class TrackingMPController_discrete:
    """
    A discretized version of a tracking MPC controller for the artificial pancreas of InsulinCo.
    """
    def __init__(self, Q:np.ndarray, S:np.ndarray, r:float, s:float, pred_time:int, sampling_time:int, discret_time:int, print_output:bool=False, verbose:bool=False) -> None:
        """
        Initialize the tracking MPC controller.

        Parameters
        -------
        :param Q: The state cost matrix.
        :param S: The terminal state cost matrix.
        :param r: The input cost.
        :param s: The slack variable cost.
        :param pred_time: The prediction horizon in minutes.
        :param sampling_time: The sampling time in minutes.
        :param discret_time: The discretization time in minutes.
        :param print_output: Print the output of the controller.
        :param verbose: Print the solver output.

        Returns
        -------
        :return: None
        """
        self.Q = Q
        self.S = S
        self.r = r
        self.s = s
        self.pred_time = pred_time
        self.sampling_time = sampling_time
        self.discret_time = discret_time

        self.K = int(pred_time / discret_time)

        self.n = 9 # number of states
        self.m = 2 # number of inputs

        self.A = None
        self.B = None
        self.h = None

        self.print_output = print_output
        self.verbose = verbose
        self.num_infeas = 0
        self.num_None_output = 0

        self._init_optimization_problem()

    def _init_optimization_problem(self) -> None:
        """
        Initialize the parametrized optimization problem and its components.

        Returns
        -------
        :return: None
        """
        # Define variables and dynamic parameters for the optimization problem
        self.x_var          = cp.Variable((self.n, self.K+1))
        self.i_var          = cp.Variable(self.K)
        self.m_var          = cp.Variable(self.K)
        self.meal_param     = cp.Parameter(self.K)
        self.x0_param       = cp.Parameter(self.n)
        self.slack_x_ub_var = cp.Variable(self.K)

        # Placeholders for parametrization
        self.A_d = cp.Parameter((self.n, self.n))
        self.B_d = cp.Parameter((self.n, self.m))
        self.h_d = cp.Parameter(self.n)
        self.xss = cp.Parameter(self.n)
        self.uss = cp.Parameter()

        # Initialize cost and constraints (parametrized)
        self.cost = 0
        self.constraints = [self.x_var[:, 0] == self.x0_param]
        
        # Iterate over the horizon K - 1 for cost and constraints
        for k in range(self.K):
            self.cost += (
                cp.quad_form(self.x_var[:, k] - self.xss, self.Q) + 
                cp.square(self.i_var[k] - self.uss) * self.r +
                cp.square(self.slack_x_ub_var[k]) * self.s
                )
            self.constraints += [
                self.x_var[:, k+1]     == self.A_d @ self.x_var[:, k] + self.B_d[:, 0] * self.i_var[k] + self.B_d[:, 1] * self.m_var[k] + self.h_d,
                self.m_var[k]          == self.meal_param[k], # make it DPP compliant with meal as variable
                self.i_var[k]          >= 0,
                self.i_var[k]          <= 0.04,
                self.x_var[8, k]       >= 70,
                self.x_var[8, k]       <= 180 + self.slack_x_ub_var[k],
                self.slack_x_ub_var[k] >= 0,
                ]
        
        # Terminal cost or constraint for stability
        self.cost += cp.quad_form(self.x_var[:, self.K] - self.xss, self.S)
        # self.constraints += [self.x_var[:, self.K_d] == self.xss]

        self.problem = cp.Problem(cp.Minimize(self.cost), self.constraints)

        if self.print_output:
            print("Is the problem DPP compliant?", self.problem.is_dpp())
            print("Is the problem DCP compliant?", self.problem.is_dcp())

    def _update_linearized_matrices_tau(self, A:np.ndarray, B:np.ndarray, h:np.ndarray) -> None:
        """
        Update the parametrized state-space matrices for the evolution of the system until tau.

        Parameters
        -------
        :param A: The state matrix.
        :param B: The input matrix.
        :param h: The constant term.

        Returns
        -------
        :return: None
        """
        self.A = A
        self.B = B
        self.h = h

    def _update_linearized_matrices(self, A:np.ndarray, B:np.ndarray, h:np.ndarray) -> None:
        """
        Update the parametrized state-space matrices for the discretized optimization problem.

        Parameters
        -------
        :param A: The state matrix.
        :param B: The input matrix.
        :param h: The constant term.

        Returns
        -------
        :return: None
        """
        self.A_d.value = A
        self.B_d.value = B
        self.h_d.value = h

    def _update_model_params(self, meal:np.ndarray, x0:np.ndarray) -> None:
        """
        Update the parametrized meal and initial state for the optimization problem.

        Parameters
        -------
        :param meal: The meal input.
        :param x0: The initial state.

        Returns
        -------
        :return: None
        """
        self.meal_param.value = meal
        self.x0_param.value = x0

    def compute_mpc(self, model, x0, tau, time_index, inputs_, xss, uss, dss) -> tuple:
        """
        Implements the tracking MPC controller.

        Parameters
        -------
        model: the T1DModel class describing the dynamics, provided by ReplayBG
        x0: the current state
        tau: delay of the system in min
        time_index: shows the current time step
        inputs_: a time series with the basal input that was/will be applied to the system
                (useful for implementing delay)
        xss, uss: the linearization point
        dss: Contains basal_handler_params and servers two functions:
            1) a dict that for the controller hyperparameters.
            2) memory for the next iteration (hence dss also being an output)
        
        Returns
        -------
        i: The basal insulin rate to administer at time[time_index+1].
        dss: [see above]
        """
        if self.print_output:
            print(f"--  Simulation time: {time_index} min  -  Infeasible solutions: {self.num_infeas} of which None output: {self.num_None_output}  --")
        
        # Save uss and xss at the beginning of the simulation
        if time_index == 0:
            self.xss.value = xss
            self.uss.value = uss
            self._update_linearized_matrices_tau(*model.get_linearization(1, xss))
            self._update_linearized_matrices(*model.get_linearization(self.discret_time, xss))

            # Initialize the open-loop input
            dss.basal_handler_params['open-loop input'] = uss * np.ones(self.K)
        
        # Optimization at every sampling time
        if (time_index % self.sampling_time) == 0:
            ## Evolve the system to include the delay
            # Linearization around the current state
            # self._update_linearized_matrices_tau(*model.get_linearization(1, x0))
            
            # Input until tau
            u_tau = np.vstack([
                inputs_[time_index:time_index+tau],
                model.get_discretized_meals(initial_time_step=time_index, duration=tau, T=1)
                ])
            
            # Evolution
            for k in range(tau):
                x0 = self.A @ x0 + self.B @ u_tau[:, k] + self.h
            
            # Update parameters for the optimization problem
            # self._update_linearized_matrices(*model.get_linearization(self.discret_time, x0))
            self._update_model_params(model.get_discretized_meals(initial_time_step=time_index+tau, duration=self.pred_time, T=self.discret_time),
                                      x0)
        
            # Solve the optimization problem
            try:
                self.problem.solve(solver=cp.MOSEK, verbose=self.verbose)

                # Check if the solution is available
                if self.i_var.value is None:
                    raise Exception("Solver did not find a feasible solution.")
            
            # Fallback solver
            except:
                try:
                    self.problem.solve(solver=cp.CLARABEL, verbose=self.verbose)

                    # Check if the solution is available
                    if self.i_var.value is None:
                        self.num_None_output += 1
                        raise Exception("Fallback solver did not find a feasible solution.")

                except:
                    self.num_infeas += 1
                    
                    control_output = dss.basal_handler_params['open-loop input'][time_index % self.sampling_time]

                    if self.print_output:
                        print(f"Forced control output: {control_output}")
                    return control_output, dss
            
            # Problem solved
            control_output = self.i_var[0].value

            # Save open-loop input
            dss.basal_handler_params['open-loop input'] = np.repeat(self.i_var[:].value, self.discret_time)

            if self.print_output:
                print(f"Optimized control output: {control_output}")
            return control_output, dss
        
        # Open-loop control
        else:
            control_output = dss.basal_handler_params['open-loop input'][time_index % self.sampling_time]
            
            if self.print_output:
                print(f"Open-loop control output: {control_output}")
            return control_output, dss